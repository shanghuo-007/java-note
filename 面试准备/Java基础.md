# Java 基础

## 语法

### 面相对象特性

继承、封装、多态

### a = a + b 与 a += b 的区别

1. 性能区别：a=a+b是加法运算 需要两次寻找地址而a+=b是增量运算有寄存器优先时 只有一次地址查找。
2. 数据类型方面：+= 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。

即前者会将a和b从short或byte提升到int类型，在赋值给a，此时会因为精度丢失导致报错。

### 3*0.1 == 0.3 将会返回什么? true 还是 false?

false，因为有些浮点数不能完全精确的表示出来。

### 能在 Switch 中使用 String 吗?

从 Java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法糖。**内部实现在 switch 中使用字符串的 hash code。**



### ==和equals

-  ==

   1. 如果是基本数据类型的比较，则比较的是值。

   2. 如果是包装类或者引用类的比较，则比较的是对象地址。

- equals

  1. 没有重写equals方法，那么比较的就是两个对象的地址，就是使用==来比较的。

  2. 重写了equals方法后，还得看equals方法是如何写的。典型的String/Integer等这些都是重写了eqauls方法的。

  在Integer中比较的是对应数字的值，在String中是把字符串拆成char数组进行一个一个比较。

  另外，直接使用`Integer i=128;`这行代码的时候，i被自动装箱成`Integer`，会执行`valueOf`方法：

  ![image-20211013165855166](https://gitee.com/Shanghuo11/picture/raw/master/img/202312021124379.png)

这里`i`的值如果在`-128 - 127`之间，则直接从缓存中加载直接赋值，而不是`new`一个`Integer`对象。

因此下面这行代码会返回`false`：

```java
Integer i1 = 128;
Integer i2 = 128;
boolean b1 = i1 == i2;		//false
boolean b2 = i1.equals(i2); //true
```



### 对hashCode()的理解?

hashCode() 的作用是获取哈希码，这个哈希码的作用是确定该对象在哈希表中的索引位置，更好的支持hash表，比如String，Set，HashTable、HashMap等。

若一个类重写了`equals`方法，却没有重写`hashCode`，可能会出现`equals`返回true，而`hashCode`结果却不同，这样就导致HashMap这样的集合无法正常使用。

## 泛型

### 什么是泛型

在定义一个类、接口或者方法时可以指定类型参数。这个类型参数我们可以在使用类、接口或者方法时动态指定。

### 如何理解Java中的泛型是伪泛型？

泛型中类型擦除 Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“伪泛型”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。

泛型擦除是指Java中的泛型只在编译期有效，在运行期间会被删除。也就是说所有泛型参数在编译后都会被清除掉。









