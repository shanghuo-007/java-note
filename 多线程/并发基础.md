# 多线程基础

## 线程使用方式

### 继承 Thread 类

```java
public class MyThread extends Thread {
    public void run() {
        // ...
    }
}
```

```java
public static void main(String[] args) {
    MyThread mt = new MyThread();
    mt.start();
}
```

不建议：最主要的一个原因就是Java是单继承模式，`MyThread`类继承了`Thread`类之后就不能再继承其他类了。

### 实现 Runnable 接口

```java
public class MyRunnable implements Runnable {
    public void run() {
        // ...
    }
}
```

```java
public static void main(String[] args) {
    MyRunnable instance = new MyRunnable();
    Thread thread = new Thread(instance);
    thread.start();
}
```

不需要再继承Thread类，减少了耦合。同时new了一个Runner对象后，这个对象可以比较方便地在各个线程之间共享。

### 实现 Callable 接口

与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。

```java
public class MyThread {

    public static final int THREAD_COUNT = 5;

    public static void main(String[] args) throws Exception {

        ExecutorService executorService = Executors.newFixedThreadPool(THREAD_COUNT);
        Runner runner = new Runner();

        for (int i = 0; i < THREAD_COUNT; i++) {
            Future<Integer> submit = executorService.submit(runner);
            //get方法会一直阻塞等到线程执行结束
            System.out.println(submit.get());
        }
        executorService.shutdown();

    }


    public static class Runner implements Callable<Integer> {

        @Override
        public Integer call() throws Exception {
            System.out.println("my thread name is:"+Thread.currentThread().getName());
            Random random = new Random();
            int sleepTime = random.nextInt(500);
            try {
                TimeUnit.SECONDS.sleep(sleepTime);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }finally {
                System.out.println(Thread.currentThread().getName()+" end after "+sleepTime+" seconds");
            }
            return sleepTime;
        }
    }

}

```

其他两种方法缺陷：

- **没有返回值：**如果想要获取某个执行结果，需要通过共享变量等方式，需要做更多的处理。
- **无法抛出异常：**不能声明式的抛出异常，增加了某些情况下的程序开发复杂度。
- **无法手动取消线程：**只能等待线程执行完毕或达到某种结束条件，无法直接取消线程任务。

和Runnable接口最主要区别就是:

- Callable接口可以有返回值；
- Callable接口可以抛出异常；

使用`Future`类来获取返回结果。Future接口的主要方法如下：

- isDone()：判断任务是否完成。
- isCancelled()：判断任务是否取消。
- get()：获取计算结果（一直等待，直至得到结果）。
- cancel(true)：取消任务。
- get(long,TimeUnit)：规定时间内获取计算结果（在long时间内等待结果，如果得到则返回；如果未得到，则结束，并抛出TimeoutException异常）。

### 实现接口 VS 继承 Thread

实现接口会更好一些，因为:

- Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；
- 类可能只要求可执行就行，继承整个 Thread 类开销过大。

## Thread类详解

- Thread.activeCount()：这个方法用于返回当前线程的线程组中活动线程的数量，返回的值只是一个估计值，因为当此方法遍历内部数据结构时，线程数可能会动态更改。）。
- Thread.checkAccess(): 检验当前正在执行的线程是否有权限修改thread的属性，这个方法我们一般不自己进行调用，Thread类的set方法在进行属性修改时都会先调用这个方法。
- Thread.currentThread()：获取当前正在运行的线程。
- Thread.dumpStack():输出线程栈，一般在debug的时候调用。
- Thread.enumerate(Thread tarray[]):??使用场景。
- Thread.getAllStackTraces():获取系统中所有线程的线程栈信息。
- thread.getName()：获取线程的名字。
- thread.getPriority()：获取线程的优先级。
- thread.getStackTrace():获取堆栈信息。
- thread.getState():获取线程状态。
- thread.getThreadGroup()：获取线程所在线程组。
- thread.interrupt()：使得指定线程中断阻塞状态，并将阻塞标志位置为true。
- thread.interrupted():测试当前线程是否被中断。
- thread.isAlive()：判断线程是否还存活着。
- thread.isDaemon()：判断线程是否是守护线程。
- thread.join()：在当前线程中加入指定线程，使得当前线程必须等待指定线程运行结束之后，才能结束。可以理解成线程插队、等待该线程终止。
- Thread.sleep(long)：强制线程睡眠一段时间。
- thread.start()：启动一个线程。
- thread.setName(name)：设置线程的名字。
- thread.setPriority(priority)：设置线程的优先级。
- thread.setDaemon(true)：将指定线程设置为守护线程。
- thread.yield()：使得当前线程退让出CPU资源，把CPU调度机会分配给同样线程优先级的线程。
- object.wait()、object.notify()、object.notifyAll()：Object类提供的线程等待和线程唤醒方法。

### 守护线程

**守护线程**可以理解为服务线程，他们的作用就是服务于其他用户线程。当系统中不存在其他用户线程时，这些守护线程也会自动消亡。比如JVM的垃圾清理线程就是守护线程。使用如下方法查看和设置线程是否是守护线程。

```java
thread.isDaemon();
thread.setDaemon(true);
```

### sleep方法

是`Thread`类的**静态**方法，调用后会进入TIMED_WAITING状态，到达指定睡眠时间后正常返回，线程处于就绪状态。

如果在睡眠期间其他线程调用了该线程的`interrupt()`方法，则该线程会在调用sleep方法的地方抛出InterruptedException异常而返回（**进入waiting状态线程的interrupt方法被调用，则这个线程会抛出InterruptedException异常**）。

### join方法

调用线程的join方法会使得调用线程进入waiting状态，直到被调用的线程执行结束，调用线程才会重新获得执行的机会。

使用场景：多个线程分别加载资源，等这些线程资源加载完毕之后对这些资源做统一汇总处理。

join方法还有一个重载方法，这个方法可以指定超时时间。

### yield()

对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。

如果这个线程在执行一个CPU时间，已经执行到一半了，调用yield之后这个线程会放弃剩下的一半CPU时间回到就绪状态。但是需要注意的是线程可以完全忽略yield方法的调用，也就是yield方法**并不是每次都调用成功的**。

### 中断

总结：

- 如果线程不处于阻塞状态，那么调用interrupt()方法仅仅是将[中断标志位]将被置为true；
- 如果当前线程处于blocked阻塞(因为调用wait、sleep和join造成的)状态时被interrupt了，那么[中断标志位]将被清除，也就是设置为false，并且收到一个InterruptedException异常。
- 如果当前线程处于blocked阻塞(因为NIO的InterruptibleChannel进行的I/O操作造成的)状态时被interrupt了，则会关闭channel，[中断标志位]将会被置为true，并且当前线程会收到一个ClosedByInterruptException异常。
- 如果当前线程处于blocked阻塞(因为NIO的Selector造成的)状态时被interrupt了，那么[中断标志位]将被置为true，然后当前线程会立即从选择器区域返回并返回值（可能为非零的值）。

需要说明的是：interrupt()方法并不是中断线程，而是中断阻塞状态，也就是将线程的[中断标志位]置为true。中断后线程将继续执行。

一般使用场景：

```java
public class InterruptExample {
    private static class MyThread2 extends Thread {
        @Override
        public void run() {
            while (!interrupted()) {
                // ..
                System.out.println("Thread running");
            }
            System.out.println("Thread end");
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread thread2 = new MyThread2();
        thread2.start();
        Thread.sleep(500);
        thread2.interrupt();
    }
}
```









## 基础线程机制

### Executor

Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。

主要有三种 Executor:

- CachedThreadPool: 一个任务创建一个线程；
- FixedThreadPool: 所有任务只能使用固定大小的线程；
- SingleThreadExecutor: 相当于大小为 1 的 FixedThreadPool。

```java
public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i < 5; i++) {
        executorService.execute(new MyRunnable());
    }
    executorService.shutdown();
}
```

### Daemon

守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。

当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。

main() 属于非守护线程。

使用 setDaemon() 方法将一个线程设置为守护线程。

```java
public static void main(String[] args) {
    Thread thread = new Thread(new MyRunnable());
    thread.setDaemon(true);
}
```



### Executor 的中断操作

调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。

```java
public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -> {
        try {
            Thread.sleep(2000);
            System.out.println("Thread run");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    });
    executorService.shutdownNow();
    System.out.println("Main run");
}
```

如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future<?> 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。

```java
Future<?> future = executorService.submit(() -> {
    // ..
});
future.cancel(true);
```





